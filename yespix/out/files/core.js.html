<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>core.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/core.browser.html">core.browser</a></li>
            
                <li><a href="../classes/core.entity.html">core.entity</a></li>
            
                <li><a href="../classes/core.file.html">core.file</a></li>
            
                <li><a href="../classes/core.ready.html">core.ready</a></li>
            
                <li><a href="../classes/core.support.html">core.support</a></li>
            
                <li><a href="../classes/core.system.html">core.system</a></li>
            
                <li><a href="../classes/entity.base.html">entity.base</a></li>
            
                <li><a href="../classes/entity.gfx.html">entity.gfx</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/core.html">core</a></li>
            
                <li><a href="../modules/entity.html">entity</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: core.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">


(function(undefined)
{




	/**************************************************************************************************************
	 * @module core
	 */

	var yespix = 
	{
		version: &#x27;0.1&#x27;,

		document: document,
		window: window,

		data:
		{

		},
	};




	/**
	 ************************************************************************************************************
	 * @class core.ready
	 */

	/**
	 * Is True when the yespix core is initiated and ready to do stuff
	 * @property isReady
	 * @type boolean
	 */
	yespix.isReady = false;

	/**
	 * 
	 * @property readyList
	 * @type array
	 */
	yespix.readyList = [];

	/**
	 * Add a function call to the ready event of the core or execute the ready state and clear the list
	 * @function ready
	 * @exemple 
	 * @return {boolean} true on success
	 * @todo ready must be triggered by the event system
	 * @chainable
	 */
	yespix.ready = function(fn)
	{
		if (yespix.isFunction(fn))
		{
			if (yespix.isReady) fn();
			else yespix.readyList.push(fn);
			return this;
		}
		for (var t=0; t&lt;yespix.readyList.length; t++) yespix.readyList[t]();
		yespix.readyList = [];
		yespix.isReady = true;
		return this;
	};


	/**
	 ************************************************************************************************************
	 * @class core.file
	 */

	yespix.file = 
	{
		/**
		 * Load some files
		 * @function load
		 * 
		 */
		load: function(fileList, complete, options)
		{
			if (!fileList) return;
			if (yespix.isString(fileList)) fileList = [fileList];
			if (yespix.isObject(complete)) 
			{
				options = complete;
				complete = function() {};
			}

			options = options || {};
			options[&#x27;complete&#x27;] = options[&#x27;complete&#x27;] || complete || function() {};
			options[&#x27;error&#x27;] = options[&#x27;error&#x27;] || function() {};
			options[&#x27;progress&#x27;] = options[&#x27;progress&#x27;] || function() {};
			options[&#x27;skip&#x27;] = options[&#x27;skip&#x27;] || function() {};
			options[&#x27;useCache&#x27;] = options[&#x27;useCache&#x27;] || true;
			options[&#x27;skipIfCache&#x27;] = options[&#x27;skipIfCache&#x27;] || true;

			//console.log(&#x27;file.load :: fileList = &#x27;+fileList);

			for (var t=0; t&lt;fileList.length; t++)
			{
				(function()
				{
					var url = fileList[t];
					//console.log(&#x27;file.load :: t=&#x27;+t+&#x27;, url = &#x27;+url);

					if (!yespix.data.file.cache[url]) yespix.data.file.cache[url] = {};
					var file = yespix.data.file.cache[url];
					var done = false;

					// init url specific options
					if (options[url])
					{
						var urlOptions = options[url];
						urlOptions = urlOptions || {};
						urlOptions[&#x27;complete&#x27;] =  urlOptions[&#x27;complete&#x27;] || options[&#x27;complete&#x27;] || complete || function() {};
						urlOptions[&#x27;error&#x27;] =  urlOptions[&#x27;error&#x27;] || options[&#x27;error&#x27;] || function() {};
						urlOptions[&#x27;skip&#x27;] =  urlOptions[&#x27;skip&#x27;] || options[&#x27;skip&#x27;] || function() {};
						urlOptions[&#x27;progress&#x27;] =  urlOptions[&#x27;progress&#x27;] || options[&#x27;progress&#x27;] || function() {};
						urlOptions[&#x27;useCache&#x27;] = urlOptions[&#x27;useCache&#x27;] || true;
						urlOptions[&#x27;skipIfCache&#x27;] = urlOptions[&#x27;skipIfCache&#x27;] || true;
					} else var urlOptions = options;

					if (urlOptions[&#x27;skipIfCache&#x27;] &amp;&amp; file.state == &#x27;loaded&#x27;)
					{
						var e = {
							file: url,
							state: &#x27;skipped&#x27;,
						};
						urlOptions[&#x27;skip&#x27;] (e);
						return core;
					}
					if (urlOptions[&#x27;useCache&#x27;] &amp;&amp; file.state == &#x27;loaded&#x27;)
					{
						done = true;
						var e = {
							file: url,
							state: file.state,
							isCache: true,
							content: file.content,
							lengthComputable: true,
							loaded: file.content.length,
							size: file.content.length,
						};
						processProgress(e);
						urlOptions[&#x27;complete&#x27;] (e);
						return core;
					}

					// start client
					var client = null;

					// create XMLHttpRequest
				    if (window.XMLHttpRequest) client = new XMLHttpRequest();
					else if (window.ActiveXObject)
				    {
				        var names = [
				            &quot;Msxml2.XMLHTTP.6.0&quot;,
				            &quot;Msxml2.XMLHTTP.3.0&quot;,
				            &quot;Msxml2.XMLHTTP&quot;,
				            &quot;Microsoft.XMLHTTP&quot;
				        ];
				        for(var i in names)
				        {
				            try
				            {
				            	client = new ActiveXObject(names[i]);
				            	break;
				            } catch(e)
				            {
				            };
				        }
					    if (!client)
					    {
					    	console.error(&quot;The browser does not support XMLHTTPRequest&quot;);
					    	return null;
					    }
					}

					function processProgress(e)
					{
						e.file = url;
						if (file.loaded&gt;e.loaded) return;

						if (!e.lengthComputable)
						{
							file.progress = 0;
							file.loaded = 0;
							file.totalSize = 0;
							file.lengthComputable = false;
						} else
						{
							file.lengthComputable = true;
							file.loaded = e.loaded;
							file.size = e.totalSize;
							if (file.size&gt;0) file.progress = parseInt(e.loaded/e.totalSize*10000)/100;
							else file.progress = 100;
							if (file.progress&gt;100) file.progress = 100;
						}
						file.progressTotal = 0;
						var totalLoaded = 0;
						var totalSize = 0;
						var allLoaded = true;
						for (var t=0; t&lt;fileList.length; t++)
						{
							if (yespix.data.file.cache[fileList[t]] &amp;&amp; yespix.data.file.cache[fileList[t]].lengthComputable)
							{
								totalLoaded += yespix.data.file.cache[fileList[t]].loaded;
								totalSize += yespix.data.file.cache[fileList[t]].size;
								if (yespix.data.file.cache[fileList[t]].loaded&lt;yespix.data.file.cache[fileList[t]].size) allLoaded=false;
							} else if (yespix.data.file.cache[fileList[t]].state==&#x27;error&#x27;)
							{
							} else
							{
								allLoaded=false;
								totalLoaded = 0;
								break
							}
						}
						if (allLoaded) file.progressTotal = 100;
						else if (totalLoaded&gt;0) file.progressTotal = parseInt(totalLoaded/totalSize*10000)/100;
						else file.progressTotal = 0;

						e.progress = file.progress;
						e.progressTotal = file.progressTotal;

						// copy progressTotal to all files
						for (var t=0; t&lt;fileList.length; t++)
						{
							if (!yespix.data.file.cache[fileList[t]]) yespix.data.file.cache[fileList[t]] = {};
							yespix.data.file.cache[fileList[t]].progressTotal = file.progressTotal;
						}
						//console.log(&#x27;processProgress :: totalLoaded=&#x27;+totalLoaded+&#x27;, totalSize=&#x27;+totalSize+&#x27;, allLoaded=&#x27;+allLoaded);
						//console.log(&#x27;file.progress=&#x27;+file.progress+&#x27;, file.progressTotal=&#x27;+file.progressTotal)
					}

					//console.log(&#x27;file.load :: start client&#x27;);

					client.onreadystatechange = function(e) //  = client.onload
					{
						if (e.lengthComputable) file.state = &#x27;processing&#x27;;

						processProgress(e);

						var state = client.readyState || e.type;
						//console.log(&#x27;onreadystatechange: file = &quot;&#x27;+url+&#x27;&quot;, state = &#x27;+state);
						if (!done &amp;&amp; (/load|loaded|complete/i.test(state) || state===4))
						{
							//yp.dump(client, &#x27;onreadystatechange : complete:&#x27;);

							e.content = this.responseText;
							e.progress = 100;
							e.progressTotal = file.progressTotal;
							e.size = file.content.length;
							e.loaded = file.content.length;
							e.htmlStatus = client.status;
							file.content = this.responseText;
							if (client.status==404)
							{
								if (yespix.options[&#x27;debug&#x27;]) console.error(&#x27;Could not load the file &quot;&#x27;+url+&#x27;&quot;&#x27;)
								e.file = url;
								file.state = &#x27;error&#x27;;
								urlOptions[&#x27;error&#x27;] (e);
								done=true;
								return;
							}

							file.state = &#x27;loaded&#x27;;
							urlOptions[&#x27;complete&#x27;] (e);
							done = true;
						}
					};
					client.addEventListener(&#x27;progress&#x27;, function(e) 
					{
						if (!done)
						{
							processProgress(e);
							urlOptions[&#x27;progress&#x27;] (e);
						}
					}, false);		

					file.state = &#x27;initiated&#x27;;
					file.content = &#x27;&#x27;;

					client.file = url;
					client.open(&#x27;GET&#x27;, url);
					client.send(&#x27;&#x27;);
				})();

			}

			return this;
		},

		/**
		 * Load a js script file and execute it
		 * @function js
		 * @param fileList {array|string} Array of the script files to load
		 * @param complete {function} Called when the load of the whole list is complete
		 * @param options {function} Called when a script load throw an error
		 * @use yespix.file.js(&#x27;my/js/file.js&#x27;);
		 * @use yespix.file.js([&#x27;file01.js&#x27;, &#x27;file02.js&#x27;, &#x27;file03.js&#x27;], function() { });
		 * @use yespix.file.js([&#x27;file01.js&#x27;, &#x27;file02.js&#x27;, &#x27;file03.js&#x27;], { complete: ... , error: ... , useCache: false});
		 */
		js: function(fileList, complete, options)
		{
			if (!fileList) return;
			if (yespix.isString(fileList)) fileList = [fileList];
			if (yespix.isObject(complete)) 
			{
				options = complete;
				complete = function() {};
			}

			options = options || {};
			options[&#x27;complete&#x27;] = options[&#x27;complete&#x27;] || complete || function() {};
			options[&#x27;error&#x27;] = options[&#x27;error&#x27;] || function() {};
			options[&#x27;progress&#x27;] = options[&#x27;progress&#x27;] || function() {};
			options[&#x27;skip&#x27;] = options[&#x27;skip&#x27;] || function() {};
			options[&#x27;useCache&#x27;] = options[&#x27;useCache&#x27;] || true;
			options[&#x27;skipIfCache&#x27;] = false;
			options[&#x27;orderedExec&#x27;] = options[&#x27;orderedExec&#x27;] || false;

			complete = options[&#x27;complete&#x27;];
/*
			function scriptAdd()
			{
				var s = document.createElement(&#x27;script&#x27;);
				var yp = core;
				s.src = list[t];
				s.async = true;
				delete s.crossOrigin;
				s.onreadystatechange = s.onload = function(e) 
				{
					if (!complete.done &amp;&amp; (/load|loaded|complete/i.test(state) || state===4))
					{
						complete.done = true;
						complete(e);
					}
				};
				document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(s);            
			}
*/
			if (!options[&#x27;orderedExec&#x27;])
			{
				options[&#x27;complete&#x27;] = function(e)
				{
//					yespix.dump(e, &#x27;js.complete&#x27;);
					eval(e.content);
					complete (e);
				};
				return this.load(fileList, options);
			} else
			{
				var token = 0;
				options[&#x27;complete&#x27;] = function(e)
				{
//						console.log(&#x27;complete::: token =&#x27;+token+&#x27;, url = &#x27;+fileList[token]);
					if (fileList[token]==e.file)
					{
						eval(e.content);
						complete (e);
						token++;
						while (fileList[token])
						{
							if (yespix.data.file.cache[fileList[token]] &amp;&amp; yespix.data.file.cache[fileList[token]].state == &#x27;loaded&#x27;)
							{
								eval(yespix.data.file.cache[fileList[token]].content);
								complete (yespix.data.file.cache[fileList[token]].eventComplete);
								token++;
							} else break;
						}
					} else yespix.data.file.cache[fileList[token]].eventComplete;
				};

				return yespix.file.load(fileList, options);
			}
		},

		/**
		 * Load a css file and add it to the document
		 * @function css
		 * @param list {array|string} Array of the script files to load
		 * @param complete {function} Called when the load of the whole list is complete
		 * @param error {function} Called when a script load throw an error
		 * @param progress {function} Called on the progress of each script load
		 */
		css: function(fileList, complete, options)
		{

			if (!fileList) return;
			if (yespix.isString(fileList)) fileList = [fileList];
			if (yespix.isObject(complete)) 
			{
				options = complete;
				complete = function() {};
			}
			// console.log(&#x27;css : fileList = &#x27;+fileList);

			options = options || {};
			options[&#x27;complete&#x27;] = options[&#x27;complete&#x27;] || complete || function() {};
			options[&#x27;error&#x27;] = options[&#x27;error&#x27;] || function() {};
			options[&#x27;progress&#x27;] = options[&#x27;progress&#x27;] || function() {};
			options[&#x27;skip&#x27;] = options[&#x27;skip&#x27;] || function() {};
			options[&#x27;useCache&#x27;] = options[&#x27;useCache&#x27;] || true;
			options[&#x27;skipIfCache&#x27;] = false;
			options[&#x27;orderedExec&#x27;] = false;

			complete = options[&#x27;complete&#x27;];
			options[&#x27;complete&#x27;] = function(e)
			{
				//console.log(&#x27;complete css &#x27;+e.file);
				var s = document.createElement(&#x27;link&#x27;);
				s.type = &#x27;text/css&#x27;;
				s.rel   = &#x27;stylesheet&#x27;;
				s.href = e.file;
				s.async = true;
				delete s.crossOrigin;
				document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(s);            
				complete (e);
			};

			return yespix.file.load(fileList, options);
		},
	};

	yespix.data.file = 
	{
		cache:
		{

		},
	};


	/**
	 * Load and initialise the yespix core
	 * @function yploader
	 * @param {object} options  namespace: string for the namespace &lt;br/&gt;
	 * 		dir_resources: directory of the resources &lt;br/&gt;
	 *		dir_engine: directory of the engine &lt;br/&gt;
	 *		dir_modules: directory of the modules &lt;br/&gt;
	 *		modules: list of modules of script files to load &lt;br/&gt;
	 *		init: function to call when the core is initiated &lt;br/&gt;
	 *		debug: if True, log some debug informations &lt;br/&gt;
	 *		
	 */
	function yploader (options, context)
	{
		if (!options) return core;
		options = options || {};
		context = context || document;

//		var modules = [&#x27;base&#x27;, &#x27;image&#x27;, &#x27;sound&#x27;]; // yespix common modules
//		var modules = [&#x27;common/baselong&#x27;, &#x27;common/test&#x27;]; // yespix common modules
		var modules = []; // yespix common modules

		options[&#x27;namespace&#x27;] = options[&#x27;namespace&#x27;] || &#x27;yespix&#x27;;
		options[&#x27;dir_resources&#x27;] = options[&#x27;dir_resources&#x27;] || &#x27;resources/&#x27;;
		options[&#x27;dir_engine&#x27;] = options[&#x27;dir_engine&#x27;] || &#x27;yespix/&#x27;;
		options[&#x27;dir_modules&#x27;] = options[&#x27;dir_modules&#x27;] || &#x27;yespix/modules/&#x27;;
		
		options[&#x27;modules&#x27;] = yespix.unique(modules.concat(options[&#x27;modules&#x27;] || []));

		options[&#x27;init&#x27;] = options[&#x27;init&#x27;] || function() {};

		for (var t=0; t&lt;options[&#x27;modules&#x27;].length; t++)
		{
			if (!/^http(s)?\:\/\//i.test(options[&#x27;modules&#x27;][t]))
			{
				options[&#x27;modules&#x27;][t] = options[&#x27;dir_modules&#x27;]+options[&#x27;modules&#x27;][t];
				if (!/\.js$/i.test(options[&#x27;modules&#x27;][t])) options[&#x27;modules&#x27;][t] =options[&#x27;modules&#x27;][t]+&#x27;.js&#x27;;
			}
			//console.log(&#x27;script &#x27;+options[&#x27;modules&#x27;][t]);
		}

		yespix.options = options;
		window[options[&#x27;namespace&#x27;]] = yespix;

		if (options[&#x27;modules&#x27;].length==0)
		{
			if (options[&#x27;canvas&#x27;]) yespix.entity.spawn(&#x27;canvas&#x27;, options.canvas);
			return yespix;
		}
		(function()
		{
			yespix.file.js(options[&#x27;modules&#x27;], {
				complete: function()
				{
					if (options[&#x27;canvas&#x27;]) yespix.entity.spawn(&#x27;canvas&#x27;, options.canvas);
					options[&#x27;init&#x27;]();
					yespix.ready();
				},
				orderedExec: true,
			});
		})();
		return yespix;
	}

	// Expose yploader
	yespix.window.yploader = yploader;



	/**
	 ************************************************************************************************************
	 * @class core.system
	 */

	/**
	 * @function clone
	 */
	yespix.clone = function (obj) 
	{
		var count = 1;
		var temp = new obj.constructor();
		for (n in obj) temp[n] = obj[n];
		return temp;
	};

	
	/**
	 * @function unique
	 */
	yespix.unique = function (arr)
	{
		var o={},
			i,
			l=arr.length,
			r=[];
		for (i=0;i&lt;l;i++) o[arr[i]]=arr[i];
		for(i in o)r.push(o[i]);
		return r;
	};

	/**
	 * @function getExtension
	 */
	yespix.getExtension = function (str)
	{
		var ext = str.split(&#x27;.&#x27;).pop();
		if (ext == str) return &#x27;&#x27;;
		return ext;     
	};
	
	/**
	 * @function getFilename
	 */
	yespix.getFilename = function (str)
	{
		return str.split(&#x27;/&#x27;).pop();
	};
	
	/**
	 * @function getDir
	 */
	yespix.getDir = function (str)
	{
		if (str.lastIndexOf(&quot;/&quot;)==-1) return &#x27;&#x27;;
		return str.substring(0, this.lastIndexOf(&quot;/&quot;) + 1);
	};
	
	/**
	 * @function getNoExtension
	 */
	yespix.getNoExtension = function (str)
	{
		var filename = yespix.getFilename(str);
		if (filename.lastIndexOf(&quot;.&quot;)==-1) return filename;
		return filename.substring(0, filename.lastIndexOf(&quot;.&quot;));
	}
	
	/**
	 * @function isInt
	 */
	yespix.isInt = function (value)
	{
		if (yespix.isString(value)) return false;
		if ((parseFloat(value) == parseInt(value)) &amp;&amp; !isNaN(value)) return true;
		return false;
	}
	
	/**
	 * @function isArray
	 */
	yespix.isArray = function (value) 
	{
		return Object.prototype.toString.call(value) === &#x27;[object Array]&#x27;;
	}
	
	/**
	 * @function isUndefined
	 */
	yespix.isUndefined = function (value) 
	{
		return value === undefined;
	}
	
	/**
	 * @function isString
	 */
	yespix.isString = function (value)
	{
		return typeof value == &#x27;string&#x27;;
	}
	
	/**
	 * @function isFunction
	 */
	yespix.isFunction = function (fn)
	{
		return fn &amp;&amp; {}.toString.call(fn) === &#x27;[object Function]&#x27;;
	}

	/**
	 * @function isObject
	 */
	yespix.isObject = function(obj)
	{
		return obj != null &amp;&amp; typeof obj === &#x27;object&#x27;;
	};

	/**
	 * @function pLength
	 */
	yespix.pLength = function (object, owned) 
	{
		owned = owned || true;
		var length = 0;
		for( var key in object ) if (owned)
		{
			if (object.hasOwnProperty(key)) length++;
		} else length++;

		return length;
	};
	
	/**
	 * Check if the value is in an array
	 * @param arr The array to check
	 * @return {boolean} True if the value is in the array
	 * @function inArray
	 * 
	yespix.inArray = function(arr, value)
	{
		return (arr.indexOf(value) != -1);
	};		

	/**
	 * @function dump
	 */
	yespix.dump = function (obj, string, expand) 
	{
		string = string || &#x27;&#x27;;
		expand = expand || 9;
		console.info(&#x27;Object dump: &#x27;+string);
		var count = 1;
		for (n in obj)
		{
			if (obj[n] === null) console.log(&#x27;  - &#x27;+n+&#x27; : null&#x27;);
			else if (typeof obj[n] === &#x27;undefined&#x27;) console.log(&#x27; - &#x27;+n+&#x27; = undefined&#x27;);
			else if (typeof obj[n] === &#x27;boolean&#x27;) console.log(&#x27; - &#x27;+n+&#x27; = &quot;&#x27;+obj[n]+&#x27;&quot; (boolean)&#x27;);
			else if (typeof obj[n] === &#x27;number&#x27;) console.log(&#x27; - &#x27;+n+&#x27; = &#x27;+obj[n]+&#x27; (integer)&#x27;);
			else if (typeof obj[n] === &#x27;function&#x27;) console.log(&#x27; - &#x27;+n+&#x27; (function)&#x27;);
			else if (yespix.isString(obj[n])) console.log(&#x27; - &#x27;+n+&#x27; = &quot;&#x27;+obj[n]+&#x27;&quot; (string)&#x27;);
			else if (yespix.isArray(obj[n]))
			{
				var str = &#x27;&#x27;;
				if (expand) for (var t=0; t&lt;obj[n].length; t++)
				{
					if (t&gt;0) str += &#x27;, &#x27;;
					str += &#x27;[&#x27;+t+&#x27;] &#x27;;
					if (obj[n][t] === null) str += &#x27;null&#x27;;
					else if (typeof obj[n][t] === &#x27;undefined&#x27;) str += &#x27;undefined&#x27;;
					else if (typeof obj[n][t] === &#x27;boolean&#x27;) str += &#x27;&quot;&#x27;+obj[n][t]+&#x27;&quot; (boolean)&#x27;;
					else if (typeof obj[n][t] === &#x27;number&#x27;) str += obj[n][t]+&#x27; (integer)&#x27;;
					else if (typeof obj[n][t] === &#x27;string&#x27;) str += &#x27;&quot;&#x27;+obj[n][t]+&#x27;&quot; (string)&#x27;;
					else if (typeof obj[n][t] === &#x27;function&#x27;) str += &#x27;function&#x27;;
					else if (yespix.isArray(obj[n][t])) str += &#x27;Array (&#x27;+obj[n][t].length+&#x27;)&#x27;;
					else str += obj[n][t];
					if (t&gt;expand)
					{
						str += &#x27; ...&#x27;;
						break;
					}
				}
				if (str==&#x27;&#x27;) console.log(&#x27; - &#x27;+n+&#x27; (array), length &#x27;+obj[n].length+&#x27;&#x27;);
				else console.log(&#x27; - &#x27;+n+&#x27; (array), length &#x27;+obj[n].length+&#x27;, content: &#x27;+str);
			} else if (yespix.isObject(obj[n]))
			{
				var str = &#x27;&#x27;;
				var t = 0;
				if (expand) for (var f in obj[n])
				{
					if (t&gt;0) str += &#x27;, &#x27;;
					str += &#x27;[&#x27;+t+&#x27;] &#x27;+f+&#x27;: &#x27;;
					if (obj[n][f] === null) str += &#x27;null&#x27;;
					else if (typeof obj[n][f] === &#x27;undefined&#x27;) str += &#x27;undefined&#x27;;
					else if (typeof obj[n][f] === &#x27;boolean&#x27;) str += &#x27;&quot;&#x27;+obj[n][f]+&#x27;&quot; (boolean)&#x27;;
					else if (typeof obj[n][f] === &#x27;number&#x27;) str += obj[n][f]+&#x27; (integer)&#x27;;
					else if (typeof obj[n][f] === &#x27;string&#x27;) str += &#x27;&quot;&#x27;+obj[n][f]+&#x27;&quot; (string)&#x27;;
					else if (typeof obj[n][f] === &#x27;function&#x27;) str += &#x27;function&#x27;;
					else if (yespix.isArray(obj[n][f])) str += &#x27;Array (&#x27;+obj[n][f].length+&#x27;)&#x27;;
					else str += obj[n][f];
					if (t&gt;expand)
					{
						str += &#x27; ...&#x27;;
						break;
					}
					t++;
				}
				if (str==&#x27;&#x27;) console.log(&#x27; - &#x27;+n+&#x27; (array), length &#x27;+obj[n].length+&#x27;&#x27;);
				else console.log(&#x27; - &#x27;+n+&#x27; (array), length &#x27;+obj[n].length+&#x27;, content: &#x27;+str);
			} else console.log(&#x27; - &#x27;+n+&#x27; : &quot;&#x27;+obj[n]+&#x27;&quot; (&#x27;+(typeof obj[n])+&#x27;)&#x27;);
		}
		
	};









	/**
	 ************************************************************************************************************
	 * @class core.support
	 */

	/**
	 * @function support
	 * Media support detection. The function yespix.support(type) return true if the requested audio or video is supported
	 *
	 * @example support(&#x27;audio&#x27;) detects if audio is supported
	 * @example support(&#x27;.mp3&#x27;) detects if mp3 extension is supported, assuming &quot;.mp3&quot; file has an audio/mpeg mimetype
	 * @example support(&#x27;audio/wav&#x27;) detects if mimetype audio/wav is supported
	 * @example support(&#x27;audio/ogg; codecs=&quot;vorbis&quot;&#x27;) detects if mimetype audio/ogg is supported with codec Vorbis. Note: Some browsers are completely ignoring the codecs and always return the same thing
	 *
	 */
	yespix.support = function(type)
	{
		console.log(&#x27;yespix.support :: type=&#x27;+type);
		if (!type) return null;
		var types = type.split(&#x27;/&#x27;);

		// type can be a media type or an extension
		if (types.length==1)
		{
			// check if the type is a media type
			if (this.data.support.types[type])
			{
				if (!this.data.support.elements[type])
				{
					this.data.support.elements[type] = document.createElement(type);
				}
				return !!this.data.support.elements[type].canPlayType;
			}
			// check if the type is an extension
			if (this.data.support.extensions[type])
			{
				type = this.data.support.extensions[type];
				types = type.split(&#x27;/&#x27;);
			} else return null;
		}


		if (this.data.support[types[0]]!=undefined &amp;&amp; this.data.support[types[0]][types[1]]!=undefined) return this.data.support[types[0]][types[1]];

		// create element if needed
		if (this.data.support.elements[types[0]]==undefined)
		{
			console.log(&#x27;type=&#x27;+type+&#x27;, types[0]=&#x27;+types[0]+&#x27;, types[1]=&#x27;+types[1]);
			this.data.support.elements[types[0]] = document.createElement(types[0]);
			if (!!this.data.support.elements[types[0]]==false) this.data.support.elements[types[0]]=false;
		}

		var e = this.data.support.elements[types[0]];
		if (!e || !!e.canPlayType==false) return false;

		var str = e.canPlayType(type);
		if (str.toLowerCase()==&#x27;no&#x27; || str==&#x27;&#x27;) this.data.support[types[0]][types[1]]=false;
		else this.data.support[types[0]][types[1]]=true;

		return this.data.support[types[0]][types[1]];
	};

	yespix.data.support =
	{
		types:
		{
			&#x27;audio&#x27;: true,
			&#x27;video&#x27;: true,
		},
		extensions: 
		{
			&#x27;.3gp&#x27;: &#x27;audio/3gpp&#x27;,
			&#x27;.ac3&#x27;: &#x27;audio/wav&#x27;,
			&#x27;.avi&#x27;: &#x27;video/avi&#x27;,
			&#x27;.kar&#x27;: &#x27;audio/midi&#x27;,
			&#x27;.mid&#x27;: &#x27;audio/midi&#x27;,
			&#x27;.m4a&#x27;: &#x27;audio/x-m4a&#x27;,
			&#x27;.mov&#x27;: &#x27;video/quicktime&#x27;,
			&#x27;.mp3&#x27;: &#x27;audio/mpeg&#x27;,
			&#x27;.mp4&#x27;: &#x27;video/mp4&#x27;,
			&#x27;.mpa&#x27;: &#x27;audio/mpeg&#x27;,
			&#x27;.mpg&#x27;: &#x27;video/mpeg&#x27;,
			&#x27;.webm&#x27;: &#x27;video/webm&#x27;,
		},
		audio: {},
		video: {},
		elements: {},
	};



	/**
	 ************************************************************************************************************
	 * @class core.browser
	 */



	yespix.isMobile = function()
	{
		if (!this.data.browser.initiated) this.browser();
		return this.data.browser.mobile;
	};
	
	yespix.browser = function()
	{
		var yespix = this;

		if (!yespix.data.browser.name)
		{
			/**
			 * @internal
			 */
			function findBrowser(str)
			{
				var data = yespix.data.browser.browserList;
				for (var i=0;i&lt;data.length;i++)
				{
					if (str.indexOf(data[i].subString) != -1)
					{
						yespix.data.browser.found = data[i];
						return data[i].identity;
					}
				}
			}

			function findOs(str)
			{
				var data = yespix.data.browser.osList;
				for (var i=0;i&lt;data.length;i++)
				{
					if (str.indexOf(data[i].subString) != -1)
					{
						yespix.data.browser.found = data[i];
						return data[i].identity;
					}
				}
			}

			function findVersion (str) 
			{
				if (!yespix.data.browser.found) return;
				var find = yespix.data.browser.found.version || yespix.data.browser.infos.name;
				var index = str.indexOf(find);
				if (index == -1) return;
				return str.substring(index+find.length+1).split(&#x27; &#x27;).shift();
			}

			function findMobile (str) 
			{
				if (!yespix.data.browser.found) return;
				return /iPhone|iPod|Android|opera mini|blackberry|palm os|palm| Mobile|hiptop|avantgo|plucker|xiino|blazer|elaine|iris|3g_t|windows ce|opera mobi| smartphone;|;iemobile/i.test(str);
			}

			yespix.data.browser.infos.initiated = true;
			yespix.data.browser.infos.name = findBrowser(navigator.userAgent) || findBrowser(navigator.vendor) || &quot;Unknown browser&quot;;
			yespix.data.browser.infos.version = findVersion(navigator.userAgent) || findVersion(navigator.appVersion) || &quot;Unknown version&quot;;
			if (yespix.data.browser.infos.version!=&quot;Unknown version&quot;)
			{
				var version = yespix.data.browser.infos.version;
				yespix.data.browser.infos.versionMajor = parseInt(version);
				if (version.indexOf(&quot;.&quot;) != -1) yespix.data.browser.infos.versionMinor = version.substring(version.indexOf(&quot;.&quot;)+1);
				else yespix.data.browser.infos.versionMinor = &#x27;&#x27;;
			}
			yespix.data.browser.infos.os = findOs(navigator.platform) || findOs(navigator.userAgent) || &quot;Unknown OS&quot;;
			yespix.data.browser.infos.mobile = findMobile(navigator.userAgent) || findMobile(navigator.platform) || false;
		}

		return yespix.data.browser.infos;
	};

	yespix.data.browser =
	{
		infos:
		{
			name: null,
			version: null,
			os: null,
			mobile: null,
			initiated: false,
		},
		browserList:
		[
			{ subString: &quot;Chrome&quot;, identity: &quot;Chrome&quot; },
			{ subString: &quot;Firefox&quot;, identity: &quot;Firefox&quot; },
			{ subString: &quot;Apple&quot;, identity: &quot;Safari&quot;, version: &quot;Version&quot; },
			{ subString: &quot;Opera&quot;, identity: &quot;Opera&quot;, version: &quot;Version&quot; },
			{ subString: &quot;MSIE&quot;, identity: &quot;IE&quot;, version: &quot;MSIE&quot; },
			{ subString: &quot;OmniWeb&quot;, identity: &quot;OmniWeb&quot;, version: &quot;OmniWeb/&quot; },
			{ subString: &quot;iCab&quot;, identity: &quot;iCab&quot; },
			{ subString: &quot;KDE&quot;, identity: &quot;Konqueror&quot; },
			{ subString: &quot;Camino&quot;, identity: &quot;Camino&quot; },
			{ subString: &quot;Netscape&quot;, identity: &quot;Netscape&quot; },
			{ subString: &quot;Gecko&quot;, identity: &quot;Mozilla&quot;, version: &quot;rv&quot; },
			{ subString: &quot;Mozilla&quot;, identity: &quot;Netscape&quot;, version: &quot;Mozilla&quot; },
		],
		osList : 
		[
			{ subString: &quot;Win&quot;, identity: &quot;Windows&quot; },
			{ subString: &quot;Mac&quot;, identity: &quot;Mac&quot; },
			{ subString: &quot;iPhone&quot;, identity: &quot;iPhone/iPod&quot; },
			{ subString: &quot;Linux&quot;, identity: &quot;Linux&quot; },
		],


	};


	/**
	 ************************************************************************************************************
	 * @class core.entity
	 */


	yespix.entity =
	{
		/**
		 *
		 */
		rootClassname: &#x27;&#x27;,
		
		classes: {}, // entity classes
		
		instances: [], // list of entity instances
		
		nextId: 1,
		nextClassId: 1,

		events: null,
		
		
		find: function(properties)
		{
			if (typeof properties == &#x27;string&#x27;) properties = { name: properties };
			var max = yespix.pLength(properties);
			var count = 0;
			for (var t=0; t&lt;this.instances.length; t++)
			{
//					console.log(&#x27;checking entity [&#x27;+t+&#x27;] with name &quot;&#x27;+this.instances[t].name+&#x27;&quot;&#x27;);
				for (var n in properties)
				{
					if (this.instances[t][n] !== undefined &amp;&amp; properties[n] == this.instances[t][n]) count++;
//						console.log(&#x27;property &quot;&#x27;+n+&#x27;&quot;, max = &#x27;+max+&#x27;, count = &#x27;+count);
					if (count&gt;=max) return this.instances[t];
				}
			}
			return null;
		},
		
		/**
		 * Returns multiple entities
		 */
		group: function(str)
		{

		},

		mixin: function(object, properties)
		{
			//console.log(&#x27;mixin :: start&#x27;)

			// copy the properties into the object
			for (fn in properties)
			{
				if (properties.hasOwnProperty(fn) &amp;&amp; fn != &#x27;__mixin&#x27;)
				{
//						console.log(&#x27;mixin :: copy property &quot;&#x27;+fn+&#x27;&quot; into object&#x27;);
					object[fn] = properties[fn];
				}
			}
			//console.log(&#x27;mixin :: end mixin&#x27;);
		},
		
		ancestors: function(name)
		{
//				console.log(&#x27;ancestors :: name = &#x27;+name);
			if (this.classes[name])
			{
				var list = [];
				for (var t=0; t&lt;this.classes[name].ancestors.length; t++)
				{
					var a = this.classes[name].ancestors[t];
					list = list.concat(this.ancestors(a));
				}
				list.push(name);
//					console.log(&#x27;ancestors :: return list length &#x27;+list.length);
				return list;
			} else
			{
//					console.log(&#x27;ancestors :: return empty list&#x27;);
				return [];
			}
		},

		define: function(name, list, properties)
		{
			//console.log(&#x27;entity.define :: defining the entity &quot;&#x27;+name+&#x27;&quot;&#x27;);

			// error if the entity class name already exists
			if (this.classes[name])
			{
				console.warn(&#x27;entity.define :: entity class name &quot;&#x27;+name+&#x27;&quot; already exists&#x27;);
				return;
			}

			// init the parameters
			if (typeof list !== &#x27;string&#x27;)
			{
				properties = list;
				list = this.rootClassname;
			}
			if (typeof properties !== &#x27;object&#x27;)
			{
				properties = {};
			}
			if (list==&#x27;&#x27;) list = this.rootClassname;
			
			// split the list into an array
			list = list.split(&#x27; &#x27;).join(&#x27;,&#x27;).split(&#x27;,&#x27;);

			// init the entity class
			this.classes[name] = 
			{
				ancestors: [],
				classname: name,
				properties: properties,
			};

			// adding the ancestors
			for (var t = 0; t &lt; list.length; t++)
			{
				if (list[t]!=&#x27;&#x27;)
				{
					if (!this.classes[list[t]])
					{
						console.warn(&#x27;entity.define :: cannot find the entity class name &quot;&#x27;+list[t]+&#x27;&quot;, skipping&#x27;);
					} else if (list[t] == name)
					{
						console.warn(&#x27;entity.define :: entity class cannot add itself to ancestors, skipping&#x27;);
					} else
					{
//							console.log(&#x27;register :: adding ancestors &quot;&#x27;+list[t]+&#x27;&quot;: &#x27;);
						this.classes[name].ancestors = this.classes[name].ancestors.concat(this.ancestors(list[t]));
//							this.classes[name].ancestors.push(list[t]);
						//this.mixin(name, this.classes[list[t]]);
//							console.log(&#x27;register :: ancestors are now &quot;&#x27;+this.classes[name].ancestors.join(&#x27;, &#x27;)+&#x27;&quot;: &#x27;);
					}
				}
			}

			this.classes[name].ancestors = yespix.unique(this.classes[name].ancestors);
			
			//console.log(&#x27;entity.define :: entity class name &quot;&#x27;+name+&#x27;&quot; added&#x27;);
			//console.log(&#x27;entity.define :: ancestors = &quot;&#x27;+this.classes[name].ancestors.join(&#x27;, &#x27;)+&#x27;&quot;&#x27;);
			//console.log(&#x27;----&#x27;);
		},

		dump: function(name)
		{
			console.log(&#x27;----------------------------------------&#x27;);
			name = name || &#x27;&#x27;;
			if (name==&#x27;&#x27;) console.log(&#x27;Engine dump :: Dump all entities classes: length &#x27;+yespix.pLength(this.classes));
			else console.log(&#x27;Engine dump :: Dump entity class &quot;&#x27;+name+&#x27;&quot;&#x27;);
			var count = 1;
			for (var n in this.classes)
			{
				if (name==&#x27;&#x27; || n==name) yespix.dump(this.classes[n], &#x27;class &#x27;+count+&#x27;: &quot;&#x27;+n+&#x27;&quot; &#x27;);
				count++;
			}
			console.log(&#x27;----------------------------------------&#x27;);
			if (name==&#x27;&#x27;) console.log(&#x27;Engine dump :: Dump all entities instances: length &#x27;+this.instances.length);
			else console.log(&#x27;Engine dump :: Dump entity instance &quot;&#x27;+name+&#x27;&quot;&#x27;);
			var count = 1;
			for (var n in this.instances)
			{
				if (name==&#x27;&#x27; || n==name) yespix.dump(this.instances[n], &#x27;instance &#x27;+count+&#x27;: &quot;&#x27;+n+&#x27;&quot; &#x27;);
				count++;
			}
			console.log(&#x27;----------------------------------------&#x27;);
		},
		

		spawn: function(name, properties)
		{
			properties = properties || {};
			
			if (name.indexOf(&#x27;,&#x27;)!=-1)
			{
				var list = name;
				name = &#x27;classtemp&#x27;+yespix.entity.nextClassId++;
				yespix.entity.define(name, list, properties);
				properties = {};
			}
			if (!this.isDefined(name))
			{
				console.warn(&#x27;entity.spawn :: entity class name &quot;&#x27;+name+&#x27;&quot; does not exist&#x27;);
				return null;
			}

			//yespix.dump(properties, &#x27;entity.spawn :: classname &quot;&#x27;+name+&#x27;&quot; with properties:&#x27;);
			//yespix.dump(this.classes[name], &#x27;spawn :: classname &quot;&#x27;+name+&#x27;&quot; with class:&#x27;);

			var entity = { };

//			var init = [];
//			if (yespix.isFunction(properties[&#x27;init&#x27;])) init.unshift(properties[&#x27;init&#x27;])

			//if (yespix.isFunction(this.classes[name].properties[&#x27;init&#x27;])) init.unshift(this.classes[name].properties[&#x27;init&#x27;])


			//console.log(&#x27;entity.spawn :: mixin with &#x27;+this.classes[name].ancestors.length+&#x27; ancestors&#x27;);
			// mixin with the ancestors
			for (var t=0; t&lt;this.classes[name].ancestors.length; t++)
			{
				//console.log(&#x27;entity.spawn :: ancestor name &quot;&#x27;+this.classes[name].ancestors[t]+&#x27;&quot;&#x27;);
				var c = this.classes[this.classes[name].ancestors[t]];
				if (c)
				{
					this.mixin(entity, c.properties);
					console.log(&#x27;entity.spawn :: copy ancestor &quot;&#x27;+this.classes[name].ancestors[t]+&#x27;&quot;&#x27;);
					//if (yespix.isFunction(c.properties[&#x27;init&#x27;])) init.unshift(c.properties[&#x27;init&#x27;])
				} else console.warn(&#x27;entity.spawn :: entity class ancestor &quot;&#x27;+this.classes[name].ancestors[t]+&#x27;&quot; does not exist for entity class name &quot;&#x27;+name+&#x27;&quot;&#x27;)
			}

			// mixin with the class name
			this.mixin(entity, this.classes[name].properties);
			

			// copy the spawn properties
			for (var fn in properties)
			{
				entity[fn] = properties[fn];
			}
			entity._class = name;
			this.instances.push(entity);

			// executing the init functions on ancestors
			yespix.entity.call(entity, &#x27;init&#x27;, [properties]);
			if (yespix.isFunction(entity.init)) entity.init(properties);

			/*
			console.log(&#x27;entity.spawn :: executing the init functions (&#x27;+init.length+&#x27;)&#x27;);
			for (var t=0; t&lt;init.length; t++)
			{
				init[t].call(entity);
			}
			*/

			// end
			//yespix.dump(entity, &#x27;spawn :: classname &quot;&#x27;+name+&#x27;&quot; with final roperties:&#x27;);
			//console.log(&#x27;entity.spawn :: classname &quot;&#x27;+name+&#x27;&quot; added :: END&#x27;);
			return entity;
		},





		/**
		 * Return True if the entity name have a defined class
		 * @function isDefined
		 * @param {string} name Name of the entity class
		 * @return {boolean} True if the entity classname exists
		 */
		isDefined: function(name)
		{
			return !!this.classes[name];
		},

		/**
		 * Returns True if the entity possesses all the ancestors
		 * @function hasAncestors
		 * @param {string} name Name of the entity
		 * @param {array|string} ancestors A string or an array of ancestor names
		 *
		 */
		hasAncestors: function(name, ancestors)
		{
			if (!this.isDefined(name)) return null;
			if (yespix.isString(ancestors)) ancestors = [ancestors];
			for (var t=0; t&lt;ancestors.length; t++) if (!yespix.inArray(this.classes[name].ancestors, ancestors[t])) return false;
			return true;
		},

		/**
		 * Call some functions of the entity ancestors of an entity
		 * @param {object} entity Entity instance
		 * @param {string} fn Function name to call
		 * @param {string} ancestors String of ancestor names (separated with &quot;,&quot;) on which the function will be called
		 * @param {array} params Parameters of the function call
		 * @return {array} Array of objects that gives the detailed results of each function
		 * @example call(entity, &#x27;test&#x27;) // call &quot;test&quot; function on every ancestors of the entity
		 * @example call(entity, &#x27;test&#x27;, [1,2,3]) // call &quot;test&quot; function on every ancestors of the entity with parameters 1, 2 and 3
		 * @example call(entity, &#x27;test&#x27;, &#x27;a, b, c&#x27;) // call &quot;test&quot; function on ancestors &quot;a&quot;, &quot;b&quot; and &quot;c&quot;
		 * @example call(entity, &#x27;test&#x27;, &#x27;a, b&#x27;, [1, 2]) // call &quot;test&quot; function on ancestors &quot;a&quot; and &quot;b&quot; with parameters 1 and 2
		 */
		call: function(entity, fn, ancestors, params) 
		{
			console.log(&#x27;call : entity._class=&#x27;+entity._class+&#x27;, fn=&#x27;+fn+&#x27;, ancestors=&#x27;+ancestors);

			if (!this.isDefined(entity._class)) return null;
			if (yespix.isString(ancestors)) ancestors = ancestors.split(&#x27;,&#x27;);
			else if (ancestors &amp;&amp; !params)
			{
				params = ancestors;
				ancestors = [];
			}
			params = params || [];
			ancestors = ancestors || [];

			if (ancestors.length&gt;0 &amp;&amp; !this.hasAncestors(entity._class, ancestors)) return null;
			else if (ancestors.length==0) ancestors = this.classes[entity._class].ancestors;

			console.log(&#x27;ancestors = &#x27;+ancestors.join(&#x27;, &#x27;));

			var result = [];
			for (var t=0; t&lt;ancestors.length; t++)
			{
				if (this.classes[ancestors[t]] &amp;&amp; this.classes[ancestors[t]].properties[fn] &amp;&amp; yespix.isFunction(this.classes[ancestors[t]].properties[fn]))
				{

					result.push({
						name: ancestors[t],
						status: &#x27;called&#x27;,
						result: this.classes[ancestors[t]].properties[fn].apply(entity, params),
						error:&#x27;&#x27;,
					});
				} else
				{
					var err = &#x27;&#x27;;
					if (!this.classes[ancestors[t]]) err = &#x27;Ancestor entity &quot;&#x27;+ancestors[t]+&#x27;&quot; does not seem to be defined&#x27;;
					else if (!this.classes[ancestors[t]].properties[fn]) err = &#x27;Ancestor entity &quot;&#x27;+ancestors[t]+&#x27;&quot; have no &quot;&#x27;+fn+&#x27;&quot; function&#x27;;
					else if (!yespix.isFunction(this.classes[ancestors[t]].properties[fn])) err = &#x27;Property &quot;&#x27;+fn+&#x27;&quot; is not a function in ancestor entity &quot;&#x27;+ancestors[n]+&#x27;&quot;&#x27;;
					else err = &#x27;Unknown error&#x27;;
					result.push({
						name: ancestors[t],
						status: &#x27;error&#x27;,
						result: null,
						error: err,
					});
					}
			}

			yespix.dump(result, &#x27;call result&#x27;);

			return result;
		},
	};
	
	

	/**
	 * @module entity
	 */

	/**
	 ************************************************************************************************************
	 * @class entity.base
	 */

	yespix.entity.define(&#x27;base&#x27;,
	{
		/**
		 * Entity class name initiated on the spawn of the entity
		 * @property _class
		 * @type string
		 */
		_class: &#x27;&#x27;,
		
		/**
		 * Array of ancestor names as strings initiated on the spawn of the entity
		 * @property _ancestors
		 * @type array
		 */
		_ancestors: [],
		
		/**
		 * Reference to the scene of the entity initiated by the scene entity
		 * @property _scene
		 * @type object
		 */
		_scene : null,

		/**
		 * Set True if the entity is active
		 * @property isActive
		 * @type boolean
		 * @default true
		 */
		isActive : true, 

		/**
		 * Set True if the entity is visible
		 * @property isVisible
		 * @type boolean
		 * @default false
		 */
		isVisible : false,

		/**
		 * Set True if the entity is global
		 * @property isGlobal
		 * @type boolean
		 * @default false
		 */
		isGlobal : false,

		/**
		 * Unique name of the entity instance
		 * @property name
		 * @type string
		 * @default &quot;entity&quot; + entity.id
		 */
		name : &#x27;&#x27;,

		/**
		 * Unique integer of the entity instance
		 * @property id
		 * @type integer
		 */
		id : 1,


		///////////////////////////////// Main functions ////////////////////////////////

		/**
		 * Return the array of assets used for the entity
		 * @sync
		 */
		assets : function()
		{
			return [];
		},

		// initilize object
		init : function() 
		{
			this._id = yespix.entity.nextId++;
			this._name = &#x27;entity&#x27;+this._id;
			console.log(&#x27;init base!&#x27;);
			return true;
		},
		
		get: function(name)
		{
			return this[name];
		},

		set: function(name, value)
		{
			this[name] = value;
			return this;
		},

		prop: function(obj)
		{
			for (n in obj) this.set(n, obj[n]);
			return this;
		}

	});
	yespix.entity.rootClassname = &#x27;base&#x27;;


	/**
	 * @class entity.gfx
	 */
	yespix.entity.define(&#x27;gfx&#x27;,
	{

		_children: null,
		_parent: null,
		_changed: false,

		///////////////////////////////// Main functions ////////////////////////////////

		asset : function()
		{
			return [];
		},

		// initilize object
		init : function() 
		{
			var lp =
			[
				{ name: &#x27;x&#x27;, init: 0, },
				{ name: &#x27;y&#x27;, init: 0, },
				{ name: &#x27;z&#x27;, init: 0, },
				{ name: &#x27;rotation&#x27;, init: 0, },
				{ name: &#x27;alpha&#x27;, init: 1.0, },
				{ name: &#x27;origin&#x27;, init: {x:0, y:0}, },
				{ name: &#x27;numChildren&#x27;, init: 0, },
			];
			//yespix.listen(this.lp);
			console.log(&#x27;init gfx!&#x27;);
			return true;
		},
		

		/**
		* @param dir - Direction to move (n,s,e,w,ne,nw,se,sw)
		* @param by - Amount to move in the specified direction
		* Quick method to move the entity in a direction (n, s, e, w, ne, nw, se, sw) by an amount of pixels.
		* @chainable
		*/
		move: function (dir, by) 
		{
			if (dir.charAt(0) === &#x27;n&#x27;) this.y -= by;
			if (dir.charAt(0) === &#x27;s&#x27;) this.y += by;
			if (dir === &#x27;e&#x27; || dir.charAt(1) === &#x27;e&#x27;) this.x += by;
			if (dir === &#x27;w&#x27; || dir.charAt(1) === &#x27;w&#x27;) this.x -= by;
			return this;
		},

		/**
		* @param x - Amount to move X
		* @param y - Amount to move Y
		* @param w - Amount to widen
		* @param h - Amount to increase height
		* Shift or move the entity by an amount. Use negative values
		* for an opposite direction.
		*/
		shift: function (x, y, w, h) 
		{
			if (x) this.x += x;
			if (y) this.y += y;
			if (w) this.w += w;
			if (h) this.h += h;
			return this;
		},
			/**@
		* #.attach
		* @comp 2D
		* @sign public this .attach(Entity obj[, .., Entity objN])
		* @param obj - Child entity(s) to attach
		* Sets one or more entities to be children, with the current entity (&#x60;this&#x60;)
		* as the parent. When the parent moves or rotates, its children move or
		* rotate by the same amount. (But not vice-versa: If you move a child, it
		* will not move the parent.) When the parent is destroyed, its children are
		* destroyed.
		* 
		* For any entity, &#x60;this._children&#x60; is the array of its children entity
		* objects (if any), and &#x60;this._parent&#x60; is its parent entity object (if any).
		*
		* As many objects as wanted can be attached, and a hierarchy of objects is
		* possible by attaching.
		*/
		attach: function () {
			var i = 0, arg = arguments, l = arguments.length, obj;
			for (; i &lt; l; ++i) {
				obj = arg[i];
				if (obj._parent) { obj._parent.detach(obj); }
				obj._parent = this;
				this._children.push(obj);
			}

			return this;
		},

		/**@
		* #.detach
		* @comp 2D
		* @sign public this .detach([Entity obj])
		* @param obj - The entity to detach. Left blank will remove all attached entities
		* Stop an entity from following the current entity. Passing no arguments will stop
		* every entity attached.
		*/
		detach: function (obj) {
			//if nothing passed, remove all attached objects
			if (!obj) {
				for (var i = 0; i &lt; this._children.length; i++) {
					this._children[i]._parent = null;
				}
				this._children = [];
				return this;
			}

			//if obj passed, find the handler and unbind
			for (var i = 0; i &lt; this._children.length; i++) {
				if (this._children[i] == obj) {
					this._children.splice(i, 1);
				}
			}
			obj._parent = null;

			return this;
		},

		/**@
		* #.origin
		* @comp 2D
		* @sign public this .origin(Number x, Number y)
		* @param x - Pixel value of origin offset on the X axis
		* @param y - Pixel value of origin offset on the Y axis
		* @sign public this .origin(String offset)
		* @param offset - Combination of center, top, bottom, middle, left and right
		* Set the origin point of an entity for it to rotate around.
		*
		* @example
		* ~~~
		* this.origin(&quot;top left&quot;)
		* this.origin(&quot;center&quot;)
		* this.origin(&quot;bottom right&quot;)
		* this.origin(&quot;middle right&quot;)
		* ~~~
		*
		* @see .rotation
		*/
		origin: function (x, y) 
		{
			//text based origin
			if (typeof x === &quot;string&quot;)
			{
				if (x === &quot;centre&quot; || x === &quot;center&quot; || x.indexOf(&#x27; &#x27;) === -1)
				{
					x = this.width / 2;
					y = this.height / 2;
				} else 
				{
					var cmd = x.split(&#x27; &#x27;);
					if (cmd[0] === &quot;top&quot;) y = 0;
					else if (cmd[0] === &quot;bottom&quot;) y = this._h;
					else if (cmd[0] === &quot;middle&quot; || cmd[1] === &quot;center&quot; || cmd[1] === &quot;centre&quot;) y = this._h / 2;

					if (cmd[1] === &quot;center&quot; || cmd[1] === &quot;centre&quot; || cmd[1] === &quot;middle&quot;) x = this._w / 2;
					else if (cmd[1] === &quot;left&quot;) x = 0;
					else if (cmd[1] === &quot;right&quot;) x = this._w;
				}
			}

			this._origin.x = x;
			this._origin.y = y;

			return this;
		},

		/**@
		* #.flip
		* @comp 2D
		* @trigger Change - when the entity has flipped
		* @sign public this .flip(String dir)
		* @param dir - Flip direction
		*
		* Flip entity on passed direction
		*
		* @example
		* ~~~
		* this.flip(&quot;X&quot;)
		* ~~~
		*/
		flip: function (dir) {
			dir = dir || &quot;X&quot;;
	                if(!this[&quot;_flip&quot; + dir]) {
	                    this[&quot;_flip&quot; + dir] = true;
	                    this.trigger(&quot;Change&quot;);
	                }
		},
	});




	/**
	 * ams_entity_object : abstract base entity with no visual
	 */
	yespix.entity.define(&#x27;sound&#x27;,
	{
		// sounds
		sounds : [],
		
		soundDefaults:
		{
			isInitiated: false, // true if soundInit() was called
			isSupported: false, // 
			isLoaded: false,
			isReady: false,
			volume: 1.0,
			duration: 0,
			formats: [],
			src: &#x27;&#x27;,
			mimeType: &#x27;&#x27;,
			loop: false,
			autoplay: false,
			element: null,
			document: yespix.document,
			assets: this.assets,
		},
		
		init : function()
		{
			var entity = this,
				count = 1;

			if (yespix.isString(this.sounds)) this.sounds = [{src: this.sounds,}];
			console.log(&#x27;init sound: array of &#x27;+this.sounds.length+&#x27; sounds&#x27;);
			
			for (var t=0; t&lt;this.sounds.length; t++)
			{
				// init the default properties
				console.log(&#x27;init the sound [&#x27;+t+&#x27;] with the default properties&#x27;);
				for (var n in this.soundDefaults)
				{
					//console.log(&#x27;copy property &#x27;+n+&#x27; : sound = &#x27;+this.sounds[t][n]+&#x27;, default = &#x27;+this.soundDefaults[n]);
					this.sounds[t][n] = this.sounds[t][n] || this.soundDefaults[n];
					//console.log(&#x27;init as &#x27;+this.sounds[t][n]);
				}
				if (this.sounds[t].name===&#x27;&#x27;) this.sounds[t].name = &#x27;sound&#x27;+count++;
			}

			/**
			 * returns a sound and executes a function on it
			 * @function sound
			 * @example sound() returns the first sound
			 * @example sound(&#x27;test&#x27;) returns the sound with name &quot;test&quot;
			 * @example sound(&#x27;/play&#x27;) plays the first sound and returns it
			 * @example sound(&#x27;test/stop&#x27;) stop the sound with name &quot;test&quot;
			 * @example sound(1) returns the sound at index 1 (index is from 0 to sounds.length-1)
			 * @example sound({name: &#x27;test&#x27; }) returns the sound with name &quot;test&quot;
			 * @example sound({ volume: 0.7 }) return the first sound with volume set to 0.7
			 */
			this.sound = function(properties)
			{
				console.log(&#x27;sound :: properties = &#x27;+properties);
				
				var fn = &#x27;&#x27;;
				if (properties == undefined) if (this.sounds[0]) return this.soundInit(this.sounds[0]); else return null;
				if (typeof properties == &#x27;string&#x27;)
				{
					properties = { name: properties };
					if (properties.name.indexOf(&#x27;/&#x27;)!=-1)
					{
						var list = properties.name.split(&#x27;/&#x27;);
						properties.name = list[0];
						fn = list[1];
						if (list[0]==&#x27;&#x27;) return this.soundInit(this.sounds[0]) [fn] ();
					}
				} else if (Object.isInt(properties)) if (this.sounds[properties]) return this.soundInit(this.sounds[properties]); else return null;
				
				var max = Object.keys(properties).length;
				var count = 0;
				for (var t=0; t&lt;this.sounds.length; t++)
				{
					console.log(&#x27;checking sound [&#x27;+t+&#x27;] with name &quot;&#x27;+this.sounds[t].name+&#x27;&quot;&#x27;);
					for (var n in properties)
					{
						if (this.sounds[t][n] !== undefined &amp;&amp; properties[n] == this.sounds[t][n]) count++;
						console.log(&#x27;property &quot;&#x27;+n+&#x27;&quot;, max = &#x27;+max+&#x27;, count = &#x27;+count);
						if (fn!=&#x27;&#x27;) return this.soundInit(this.sounds[t]) [fn] ();
						if (count&gt;=max) return this.soundInit(this.sounds[t]);
					}
				}
				return null;
			};
			
			this.soundInit = function(sound)
			{
				parent = this;
				
				// no sound, init all the sounds
				if (sound == undefined)
				{
					for (var t=0; t&lt;this.sounds.length; t++) this.soundInit(this.sounds[t]);
					return true;
				}
				
				// sound already initiated
				if (sound.isInitiated) return sound;
				
				sound.isInitiated = true;
				sound.element = document.createElement(&quot;audio&quot;);
				
				// alias of yespix.support
				sound.support = function(format)
				{
					if (format == undefined) return false;
					return yespix.support(format);
				};
				
				// add source to the audio element and to the assets list
				sound.changeSource = function(source)
				{
					if (this.support(&#x27;.&#x27;+yespix.getExtension(source)))
					{
						//yespix.dump(parent);
						this.isSupported = true;
						this.element.src = source;

						if (this.volume&lt;0) this.volume = 0;
						else if (this.volume&gt;1) this.volume = 1;
						this.element.volume = this.volume;
						return true;
					}
					return false;
				};
				
				sound.load = function()
				{
					if (!this.isSupported) return this;
					this.element.load();
					return this;
				};
				
				sound.play = function()
				{
					if (!this.isSupported) return this;
					this.element.play();
					return this;
				};
				
				sound.isPlaying = function()
				{
					if (!this.isSupported) return null;
					return !this.element.paused;
				};
				
				sound.pause = function()
				{
					if (!this.isSupported) return this;
					this.element.pause();
					return this;
				};
				
				sound.isPaused = function()
				{
					if (!this.isSupported) return null;
					return !!this.element.paused;
				};
				
				sound.mute = function()
				{
					if (!this.isSupported) return null;
					this.element.muted = true;
					return this;
				};
				
				sound.unmute = function()
				{
					if (!this.isSupported) return this;
					this.element.muted = false;
					return this;
				};
				
				sound.muteToggle = function()
				{
					if (!this.isSupported) return this;
					if (this.isMuted()) this.unmute(); else this.mute();
					return this;
				};
				
				sound.isMuted = function()
				{
					if (!this.isSupported) return null;
					return this.element.muted;
				};
				
				sound.restart = function()
				{
					if (!this.isSupported) return this;
					this.stop().play();
					return this;
				};
				
				sound.stop = function()
				{
					if (!this.isSupported) return this;
					this.element.pause();
					this.setTime(0);
					return this;
				};
				
				sound.setVolume = function(n)
				{
					if (!this.isSupported) return this;
					this.volume = n;
					if (this.volume&lt;0) this.volume = 0;
					else if (this.volume&gt;1) this.volume = 1;
					this.element.volume = this.volume;
					return this;
				};
				
				sound.volumeUp = function()
				{
					if (!this.isSupported) return this;
					this.volume -= 0.1;
					if (this.volume&lt;0) this.volume = 0;
					else if (this.volume&gt;1) this.volume = 1;
					this.element.volume = this.volume;
					return this;
				};
				
				sound.volumeDown = function()
				{
					if (!this.isSupported) return this;
					this.volume += 0.1;
					if (this.volume&lt;0) this.volume = 0;
					else if (this.volume&gt;1) this.volume = 1;
					this.element.volume = this.volume;
					return this;
				};
				
				sound.setTime = function(time)
				{
					if (!this.isSupported) return this;
					this.element.currentTime = time;
					return this;
				};
				
				sound.isEnded = function()
				{
					if (!this.isSupported) return null;
					return this.element.ended;
				};

				//yespix.dump(sound, &#x27;sound&#x27;);
				if (sound.src !== undefined &amp;&amp; sound.src !== &#x27;&#x27;)
				{
					if (yespix.isArray(sound.src))
					{
						// check every sources to add the source element
						for (var t=0; t&lt;sound.src.length; t++) if (sound.src[t] &amp;&amp; !sound.isSupported) sound.changeSource(sound.src[t]);
					} else if (yespix.isArray(sound.formats) &amp;&amp; sound.formats.length&gt;0)
					{
						// check every formats to add the source element
						for (var t=0; t&lt;sound.formats.length; t++) if (sound.formats[t] &amp;&amp; !sound.isSupported) sound.changeSource(sound.src+&#x27;.&#x27;+sound.formats[t]);
					} else if (yespix.isString(sound.src) &amp;&amp; sound.src != &#x27;&#x27;)
					{
						// add the source
						sound.changeSource(sound.src);
					}
				}
				//this.soundInit();
				return sound;
			};
			
			this.assets = function(sound)
			{
				parent = this;
				
				// no sound defined, call assets on all the sounds
				if (sound == undefined)
				{
					var assets = []
					for (var t=0; t&lt;this.sounds.length; t++) assets = assets.concat(this.assets(this.sounds[t]));
					return assets;
				}
				
				if (sound.src !== undefined &amp;&amp; sound.src !== &#x27;&#x27;)
				{
					if (yespix.isArray(sound.src))
					{
						// check every sources in array to add the source element
						for (var t=0; t&lt;sound.src.length; t++) if (sound.src[t] &amp;&amp; yespix.support(&#x27;.&#x27;+yespix.getExtension(sound.src[t])))
						{
							sound.src = sound.src[t];
							sound.isSupported = true;
							return [sound.src];
						}
						return [];
					} else if (yespix.isArray(sound.formats) &amp;&amp; sound.formats.length&gt;0)
					{
						// check every formats to add the source element
						for (var t=0; t&lt;sound.formats.length; t++) if (sound.formats[t] &amp;&amp; yespix.support(&#x27;.&#x27;+sound.formats[t]))
						{
							sound.src = sound.src+&#x27;.&#x27;+sound.formats[t];
							sound.isSupported = true;
							return [sound.src];
						}
					} else if (yespix.isString(sound.src) &amp;&amp; sound.src.indexOf(&#x27;|&#x27;)!=-1)
					{
						var s = sound.src.split(&#x27;|&#x27;);
						for (var t=0; t&lt;s.length; t++) if (s[t] &amp;&amp; yespix.support(&#x27;.&#x27;+yespix.getExtension(s[t])))
						{
							sound.src = s[t];
							sound.isSupported = true;
							return [sound.src];
						}
						return [];
					} else if (yespix.isString(sound.src) &amp;&amp; sound.src != &#x27;&#x27;)
					{
						if (yespix.support(&#x27;.&#x27;+yespix.getExtension(sound.src)))
						{
							sound.isSupported = true;
							return [sound.src];
						}
					}
				}
				return [];
			};
			
		},
	});
	

	yespix.entity.define(&#x27;canvas&#x27;,
	{
		canvasOptions: null,
		el: null,
		ctx: null,
		document: null,

		init: function(options)
		{
			this.create(options);
		},

		create: function(options)
		{
			options = options || {};
			options.document = options.document || yespix.document;
			options.width = options.width || 800; // @todo default must be set to client width
			options.height = options.height || 600; // @todo default must be set to client height
			options.style = options.style || {};
			options.id = options.id || &#x27;canvas&#x27;+this._id;
			options.autoAppend = options.autoAppend || true;

			this.canvasOptions = options;
			this.document = options.document;

			var canvas = document.createElement(&#x27;canvas&#x27;);
			canvas.id = options.id;
			canvas.width = options.width;
			canvas.height = options.height;
			for (var n in options.style) canvas.style[n] = options.style[n];

			if (options.autoAppend)
			{
				var body = this.document.getElementsByTagName(&quot;body&quot;)[0];
				body.appendChild(canvas);
			}

			this.use(canvas);
		},

		use: function(canvasElement)
		{
			this.el = canvasElement;
			this.ctx = this.el.getContext(&#x27;2d&#x27;);
		},

	});

	
	yespix.entity.define(&#x27;scene&#x27;,
	{
		sceneOptions: null,
		document: null,

		init: function(options)
		{
			this.create(options);
		},

		create: function(options)
		{
			options = options || {};
			options.document = options.document || yespix.document;

			this.sceneOptions = options;
		},

	});


	yespix.entity.define(&#x27;image&#x27;, &#x27;gfx&#x27;,
	{
		// images
		images : [],
		
		imageDefaults:
		{
			isInitiated: false, // true if imageInit() was called
			isLoaded: false,
			src: &#x27;&#x27;,
			element: null,
			document: yespix.document,
		},
		
		init : function()
		{
			var entity = this,
				count = 1;
			
			console.log(&#x27;init image&#x27;);
			yespix.dump(this);
			if (yespix.isString(this.images)) this.images = [{ src: this.images}];
			console.log(&#x27;init image: array of &#x27;+this.images.length+&#x27; images&#x27;);
			
			for (var t=0; t&lt;this.images.length; t++)
			{
				// init the default properties
				console.log(&#x27;init the image [&#x27;+t+&#x27;] with the default properties&#x27;);
				for (var n in this.imageDefaults)
				{
					console.log(&#x27;copy property &#x27;+n+&#x27; : image = &#x27;+this.images[t][n]+&#x27;, default = &#x27;+this.imageDefaults[n]);
					this.images[t][n] = this.images[t][n] || this.imageDefaults[n];
					console.log(&#x27;init as &#x27;+this.images[t][n]);
				}
				if (this.images[t].name===&#x27;&#x27;) this.images[t].name = &#x27;image-&#x27;+count++;
			}
			
			this.image = function(properties)
			{
				console.log(&#x27;image :: properties = &#x27;+properties);
				
				if (properties == undefined) if (this.images[0]) return this.imageInit(this.images[0]); else return null;
				if (typeof properties == &#x27;string&#x27;) properties = { name: properties };
				else if (Object.isInt(properties)) if (this.images[properties]) return this.imageInit(this.images[properties]); else return null;
				
				var max = Object.keys(properties).length;
				var count = 0;
				for (var t=0; t&lt;this.images.length; t++)
				{
					console.log(&#x27;checking image [&#x27;+t+&#x27;] with name &quot;&#x27;+this.images[t].name+&#x27;&quot;&#x27;);
					for (var n in properties)
					{
						if (this.images[t][n] !== undefined &amp;&amp; properties[n] == this.images[t][n]) count++;
						console.log(&#x27;property &quot;&#x27;+n+&#x27;&quot;, max = &#x27;+max+&#x27;, count = &#x27;+count);
						if (count&gt;=max) return this.imageInit(this.images[t]);
					}
				}
				return null;
				
		
			};
			
			this.imageInit = function(image)
			{
				var parent = this;
				
				// no sound, init all the sounds
				if (image == undefined)
				{
					for (var t=0; t&lt;this.images.length; t++) this.imageInit(this.images[t]);
					return true;
				}
				
				// sound already initiated
				if (image.isInitiated) return image;
				
				image.isInitiated = true;
				image.element = document.createElement(&quot;img&quot;);
				
				// add source to the audio element
				image.changeSource = function(source)
				{
					this.element.src = source;
					return true;
				};
				
				image.draw = function()
				{
					
				};
				
				
				
				if (image.src !== undefined &amp;&amp; image.src !== &#x27;&#x27;)
				{
					image.changeSource(image.src);
				}
				
				console.log(&#x27;imageInit :: src #1 = &#x27;+image.element.src);
				
				return image; //source != &#x27;&#x27;;
			};
			
			this.imageInit();
		},
		
		

		
		
	});


	
})();
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
